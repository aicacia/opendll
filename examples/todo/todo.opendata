edge owns<Owner, Ownable> {
  from: Owner
  to: Ownable
  constraints: {
    functional_to: true // One owner per to object
    required_to: false  // make ownership mandatory for Ownable objects
    on_delete: cascade  // deletion behavior i.e. cascade or null
  }
}

edge owned inverses owns {}

edge assigned_to<A, B> {
  from: A
  to: B
  constraints: { 
    functional_to: true 
  }
}

edge has_assignment inverses assigned_to {}

node Role {
  @primary_key
  name: string

  @has_assignment()
  permissions: Set<Permission>
}

enum Permissions {
  UsersRead = "users:read"
  Admin = "admin"
}

node Permission {
  @primary_key
  name: Permissions

  @assigned_to()
  roles: Set<Role>
}

node User {
  @primary_key
  id: usize

  name: string

  created_at: DateTime
  updated_at: DateTime 

  @assigned_to
  roles: Set<Role>

  @owns
  todos: Set<Todo>

  fn is_admin(user? User) -> bool {
    if user == null {
      return false
    }
    user.role.permissions.some(p => p.name == Permissions.Admin)
  }

  fn has_permission(self, permission Permissions) -> bool {
    user.role.permissions.some(p => p.name == permission)
  }
}

node Todo {
  @primary_key
  id: usize

  title: string
  description: string?
  completed: bool
  created_at: DateTime
  updated_at: DateTime 

  @owned_by()
  user: User
}